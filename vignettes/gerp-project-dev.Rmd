---
title: "Developing gerp() function"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
vignette: >
  %\VignetteIndexEntry{Developing gerp() function}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

```{r setup}
library(gerp)
library(fs)
library(withr)
```

```{r x, eval=TRUE}
x <- "/Users/mjfrigaard/projects/_dev/test"
```

```{r}
ger_go(x)
```



```{r proj}
proj <- new.env(parent = emptyenv())
proj
```

```{r proj_get_}
proj_get_ <- function() proj$cur
proj_get_
```

```{r proj_active}
proj_active <- function() !is.null(proj_get_())
proj_active()
```

```{r proj_set_}
proj_set_ <- function(path) {
  old <- proj$cur
  proj$cur <- path
  invisible(old)
}
proj_set_(x)
```

```{r proj_get}
proj_get <- function() {
  # Called for first time so try working directory
  if (!proj_active()) {
    usethis::proj_set(".")
  }
  proj_get_()
}
proj_get()
```

```{r user_path_prep}
user_path_prep <- function(path) {
  ## usethis uses fs's notion of home directory
  ## this ensures we are consistent about that
  fs::path_expand(path)
}
user_path_prep(x)
```

```{r is_in_proj}
is_in_proj <- function(path) {
  if (!proj_active()) {
    return(FALSE)
  }
  identical(
    proj_get(),
    ## use path_abs() in case path does not exist yet
    fs::path_common(c(proj_get(), path_expand(path_abs(path))))
  )
}
is_in_proj(x)
```

```{r proj_rel_path}
proj_rel_path <- function(path) {
  if (is_in_proj(path)) {
    as.character(path_rel(path, start = usethis::proj_get()))
  } else {
    path
  }
}
proj_rel_path(x)
```

```{r proj_find}
proj_find <- function(path = ".") {
  tryCatch(
    rprojroot::find_root(proj_crit(), path = path),
    error = function(e) NULL
  )
}
proj_find(x)
```

```{r possibly_in_proj}
possibly_in_proj <- function(path = ".") !is.null(proj_find(path))
possibly_in_proj(x)
```

## `is_quiet()`

```{r is_quiet}
# is_quiet -------
is_quiet <- function() {
  isTRUE(getOption("usethis.quiet", default = FALSE))
}
```


# ui functions 

```{r ui}
# ui_value  -----
ui_value <- function(x) {
  if (is.character(x)) {
    x <- encodeString(x, quote = "'")
  }
  x <- crayon::blue(x)
  x <- glue::glue_collapse(x, sep = ", ")
  x
}
ui_value(x)
```

```{r ui_inform}
# ui_inform  -----
ui_inform <- function(...) {
  if (!is_quiet()) {
    rlang::inform(paste0(...))
  }
  invisible()
}
ui_inform(x)
```

```{r ui_stop}
ui_stop <- function(x, .envir = parent.frame()) {
  x <- glue::glue_collapse(x, "\n")
  x <- glue::glue(x, .envir = .envir)

  cnd <- structure(
    class = c("usethis_error", "error", "condition"),
    list(message = x)
  )
  stop(cnd)
}
```


```{r ui_yeah}
ui_yeah <- function(x,
      yes = c("Yes", "Definitely", "For sure", "Yup", "Yeah", "I agree", "Absolutely"),
      no = c("No way", "Not now", "Negative", "No", "Nope", "Absolutely not"),
      n_yes = 1, n_no = 2, shuffle = TRUE,
      .envir = parent.frame()) {
  x <- glue::glue_collapse(x, "\n")
  x <- glue::glue(x, .envir = .envir)

  if (!rlang::is_interactive()) {
    ui_stop(c(
      "User input required, but session is not interactive.",
      "Query: {x}"
    ))
  }

  n_yes <- min(n_yes, length(yes))
  n_no <- min(n_no, length(no))

  qs <- c(sample(yes, n_yes), sample(no, n_no))

  if (shuffle) {
    qs <- sample(qs)
  }

  # TODO: should this be ui_inform()?
  rlang::inform(x)
  out <- utils::menu(qs)
  out != 0L && qs[[out]] %in% yes
}
# ui_yeah(x)
```

```{r ui_nope}
ui_nope <- function(x,
      yes = c("Yes", "Definitely", "For sure", "Yup", "Yeah", "I agree", "Absolutely"),
      no = c("No way", "Not now", "Negative", "No", "Nope", "Absolutely not"),
      n_yes = 1, n_no = 2, shuffle = TRUE,
      .envir = parent.frame()) {
  # TODO(jennybc): is this correct in the case of no selection / cancelling?
  !ui_yeah(
    x = x, yes = yes, no = no,
    n_yes = n_yes, n_no = n_no,
    shuffle = shuffle,
    .envir = .envir
  )
}
# ui_nope(x)
```


```{r ui_line}
ui_line <- function(x = character(), .envir = parent.frame()) {
  x <- glue::glue_collapse(x, "\n")
  x <- glue::glue(x, .envir = .envir)
  ui_inform(x)
}
ui_line(x)
```

```{r ui_path}
ui_path <- function(x, base = NULL) {
  is_directory <- fs::is_dir(x) | grepl("/$", x)
  if (is.null(base)) {
    x <- proj_rel_path(x)
  } else if (!identical(base, NA)) {
    x <- path_rel(x, base)
  }
  # rationalize trailing slashes
  x <- fs::path_tidy(x)
  x <- ifelse(is_directory, paste0(x, "/"), x)
  ui_value(x)
}
ui_path(x)
```

```{r indent}
# indent -----
indent <- function(x, first = "  ", indent = first) {
  x <- gsub("\n", paste0("\n", indent), x)
  paste0(first, x)
}
```

```{r ui_bullet}
ui_bullet <- function(x, bullet = cli::symbol$bullet) {
  bullet <- paste0(bullet, " ")
  x <- indent(x, bullet, "  ")
  ui_inform(x)
}
ui_bullet(x)
```

```{r ui_todo}
ui_todo <- function(x, .envir = parent.frame()) {
  x <- glue::glue_collapse(x, "\n")
  x <- glue::glue(x, .envir = .envir)
  ui_bullet(x, crayon::red(cli::symbol$bullet))
}
```

```{r ui_code}
ui_code <- function(x) {
  x <- encodeString(x, quote = "`")
  x <- crayon::silver(x)
  x <- glue::glue_collapse(x, sep = ", ")
  x
}
```


```{r ui_code_block}
ui_code_block <- function(x,
                          copy = rlang::is_interactive(),
                          .envir = parent.frame()) {
  x <- glue::glue_collapse(x, "\n")
  x <- glue::glue(x, .envir = .envir)

  block <- indent(x, "  ")
  block <- crayon::silver(block)
  ui_inform(block)

  if (copy && clipr::clipr_available()) {
    x <- crayon::strip_style(x)
    clipr::write_clip(x)
    ui_inform("  [Copied to clipboard]")
  }
}
ui_code_block(x)
```


```{r ui_done}
ui_done <- function(x, .envir = parent.frame()) {
  x <- glue::glue_collapse(x, "\n")
  x <- glue::glue(x, .envir = .envir)
  ui_bullet(x, crayon::green(cli::symbol$tick))
}
ui_done(x)
```



# Challenege functions

## `challenge_home_directory()`

```{r challenge_home_directory}
challenge_home_directory <- function(path) {
  homes <- unique(c(fs::path_home(), fs::path_home_r()))
  if (!path %in% homes) {
    return(invisible())
  }

  qualification <- if (is_windows()) {
    glue::glue("a special directory, i.e. some applications regard it as ")
  } else {
    ""
  }
  ui_line("
    {ui_path(path)} is {qualification}your home directory.
    It is generally a bad idea to create a new project here.
    You should probably create your new project in a subdirectory.")
  if (ui_nope("Do you want to create anyway?")) {
    ui_stop("Good move! Cancelling project creation.")
  }
  invisible()
}
challenge_home_directory(x)
```

## `challenge_nested_project()`

```{r challenge_nested_project}
challenge_nested_project <- function(path, name) {
  if (!possibly_in_proj(path)) {
    return(invisible())
  }

  # creates an undocumented backdoor we can exploit when the interactive
  # approval is impractical, e.g. in tests
  if (isTRUE(getOption("usethis.allow_nested_project", FALSE))) {
    return(invisible())
  }
  ui_line(
    "New project {ui_value(name)} is nested inside an existing project \\
    {ui_path(path)}, which is rarely a good idea.
    If this is unexpected, the here package has a function, \\
    {ui_code('here::dr_here()')} that reveals why {ui_path(path)} \\
    is regarded as a project."
  )
  if (ui_nope("Do you want to create anyway?")) {
    ui_stop("Cancelling project creation.")
  }
  invisible()
}
```

## `check_path_is_directory()`

```{r check_path_is_directory}
# check_path_is_directory -------------
check_path_is_directory <- function(path) {
  if (!fs::file_exists(path)) {
    ui_stop("Directory {ui_path(path)} does not exist.")
  }
  if (fs::is_link(path)) {
    path <- link_path(path)
  }
  if (!fs::is_dir(path)) {
    ui_stop("{ui_path(path)} is not a directory.")
  }
}
check_path_is_directory(x)
```

# Create

## create_directory()

```{r create_directory}
# create_directory ----------
create_directory <- function(path) {
  if (fs::dir_exists(path)) {
    return(
      invisible(FALSE)
      )
  } else if (fs::file_exists(path)) {
    ui_stop("{ui_path(path)} exists but is not a directory.")
  }
  fs::dir_create(path, recurse = TRUE)
  ui_done("Creating {ui_path(path)}")
  invisible(TRUE)
}
```


```{r gerp}
gerp <- function(path, rstudio = rstudioapi::isAvailable(), open = rlang::is_interactive()) {
  # defined above (converts to fs path)
  path <- user_path_prep(path)
  # gets the base name of directory
  name <- fs::path_file(fs::path_abs(path))
  
  if (fs::dir_exists(path)) {
    ui_stop("Directory {ui_path(path)} already exists!")
  }
  
  # defined above
  challenge_nested_project(fs::path_dir(path), name)
  challenge_home_directory(path)
  

  
  create_directory(path)
  
  # code
  ger_code(folder_name = paste0(path, "/R"))
  # data
  ger_data(folder_name = path)
  # ref
  ger_ref(folder_name = path)
  
  rstudioapi::initializeProject(path = path)
  
  # open new session
  rstudioapi::openProject(path = path, newSession = TRUE)
  
}
```

```{r}
gerp(x)
# proj_get()
```

```{r}
fs::dir_tree("/Users/mjfrigaard/projects/_dev/gerp-testing/", recurse = 3)
```

```{r}
unlink("/Users/mjfrigaard/projects/_dev/gerp-testing/gerp_test", force = TRUE)
```

```{r, eval=FALSE}
  if (rstudio) {
    usethis::use_rstudio()
  } else {
    ui_done("Writing a sentinel file {ui_path('.here')}")
    ui_todo("Build robust paths within your project via {ui_code('here::here()')}")
    ui_todo("Learn more at <https://here.r-lib.org>")
    fs::file_create(usethis::proj_path(".here"))
  }

  if (open) {
    if (usethis::proj_activate(usethis::proj_get())) {
      # working directory/active project already set; clear the scheduled
      # restoration of the original project
      withr::deferred_clear()
    }
  }
  invisible(proj_get())
}
```







